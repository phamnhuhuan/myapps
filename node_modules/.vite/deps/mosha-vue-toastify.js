import "./chunk-763AARI2.js";
import {
  Transition,
  computed,
  createBlock,
  createCommentVNode,
  createVNode,
  defineComponent,
  onMounted,
  onUnmounted,
  openBlock,
  ref,
  render,
  renderSlot,
  resolveComponent,
  toDisplayString,
  watchEffect,
  withCtx
} from "./chunk-6XECGMJ4.js";
import "./chunk-CF3WPAMV.js";

// node_modules/mosha-vue-toastify/dist/mosha-vue-toastify.es.js
var e = Object.defineProperty;
var t = Object.defineProperties;
var o = Object.getOwnPropertyDescriptors;
var n = Object.getOwnPropertySymbols;
var s = Object.prototype.hasOwnProperty;
var i = Object.prototype.propertyIsEnumerable;
var r = (t2, o2, n2) => o2 in t2 ? e(t2, o2, { enumerable: true, configurable: true, writable: true, value: n2 }) : t2[o2] = n2;
var l = (e2, t2) => {
  for (var o2 in t2 || (t2 = {}))
    s.call(t2, o2) && r(e2, o2, t2[o2]);
  if (n)
    for (var o2 of n(t2))
      i.call(t2, o2) && r(e2, o2, t2[o2]);
  return e2;
};
var a = (e2, n2) => t(e2, o(n2));
var C = { type: "default", timeout: 5e3, showCloseButton: true, position: "top-right", transition: "bounce", hideProgressBar: false, swipeClose: true };
var M;
var E;
(E = M || (M = {}))[E.TITLE_ONLY = 0] = "TITLE_ONLY", E[E.TITLE_DESCRIPTION = 1] = "TITLE_DESCRIPTION", E[E.COMPONENT = 2] = "COMPONENT", E[E.VNODE = 3] = "VNODE";
var z = { "top-left": { bounce: "mosha__bounceInLeft", zoom: "mosha__zoomIn", slide: "mosha__slideInLeft" }, "top-right": { bounce: "mosha__bounceInRight", zoom: "mosha__zoomIn", slide: "mosha__slideInRight" }, "top-center": { bounce: "mosha__bounceInDown", zoom: "mosha__zoomIn", slide: "mosha__slideInDown" }, "bottom-center": { bounce: "mosha__bounceInUp", zoom: "mosha__zoomIn", slide: "mosha__slideInUp" }, "bottom-right": { bounce: "mosha__bounceInRight", zoom: "mosha__zoomIn", slide: "mosha__slideInRight" }, "bottom-left": { bounce: "mosha__bounceInLeft", zoom: "mosha__zoomIn", slide: "mosha__slideInLeft" } };
var S = (e2, t2) => createVNode(e2, t2);
var L = (e2, t2 = 300) => {
  let o2;
  return (...n2) => {
    o2 && (clearTimeout(o2), o2 = void 0), o2 = setTimeout(() => e2(...n2), t2);
  };
};
var O = (e2, t2, o2) => {
  const n2 = ref(), s2 = ref(void 0), i2 = ref(), r2 = (e3) => e3 instanceof MouseEvent, p = (u) => {
    false !== o2 && n2.value && (r2(u) ? s2.value = n2.value.clientX - u.clientX : s2.value = n2.value.touches[0].clientX - u.touches[0].clientX, i2.value = a(l({}, i2.value), { transition: "none" }), e2.endsWith("left") ? i2.value.left = -s2.value + "px !important" : e2.endsWith("right") ? i2.value.right = `${s2.value}px !important` : s2.value > 0 ? i2.value.left = -s2.value + "px !important" : i2.value.right = `${s2.value}px !important`, Math.abs(s2.value) > 200 && t2());
  }, h = (e3) => {
    false !== o2 && (n2.value && (n2.value = void 0), s2.value && (s2.value = void 0), removeEventListener(e3, p));
  };
  return onUnmounted(() => {
    false !== o2 && (h("mousemove"), h("touchmove"));
  }), { swipedDiff: s2, swipeStart: n2, swipeStyle: i2, swipeHandler: p, startSwipeHandler: (t3) => {
    if (false === o2)
      return;
    n2.value = t3;
    const a2 = r2(t3) ? "mousemove" : "touchmove", u = r2(t3) ? "mouseup" : "touchend";
    addEventListener(a2, p), addEventListener(u, () => ((t4) => {
      const o3 = { transition: "left .3s ease-out", left: 0 }, r3 = { transition: "right .3s ease-out", right: 0 }, a3 = { transition: "all .3s ease-out", left: 0, right: 0 };
      e2.endsWith("left") ? i2.value = l(l({}, i2.value), o3) : e2.endsWith("right") ? i2.value = l(l({}, i2.value), r3) : i2.value = l(l({}, i2.value), a3), n2.value = void 0, s2.value = void 0, removeEventListener(t4, p);
    })(a2));
  }, cleanUpMove: h };
};
var N = defineComponent({ props: { type: { type: String, default: "default" } } });
var B = { class: "mosha__icon" };
var P = { key: 0, xmlns: "http://www.w3.org/2000/svg", height: "32px", viewBox: "0 0 24 24", width: "32px", fill: "#ffffff" };
var D = createVNode("path", { d: "M4.47 21h15.06c1.54 0 2.5-1.67 1.73-3L13.73 4.99c-.77-1.33-2.69-1.33-3.46 0L2.74 18c-.77 1.33.19 3 1.73 3zM12 14c-.55 0-1-.45-1-1v-2c0-.55.45-1 1-1s1 .45 1 1v2c0 .55-.45 1-1 1zm1 4h-2v-2h2v2z" }, null, -1);
var H = { key: 1, xmlns: "http://www.w3.org/2000/svg", height: "32px", viewBox: "0 0 24 24", width: "32px", fill: "#ffffff" };
var k = createVNode("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 11c-.55 0-1-.45-1-1V8c0-.55.45-1 1-1s1 .45 1 1v4c0 .55-.45 1-1 1zm1 4h-2v-2h2v2z" }, null, -1);
var V = { key: 2, xmlns: "http://www.w3.org/2000/svg", height: "32px", viewBox: "0 0 24 24", width: "32px", fill: "#ffffff" };
var R = createVNode("path", { d: "M0 0h24v24H0V0z", fill: "none" }, null, -1);
var $ = createVNode("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM9.29 16.29L5.7 12.7c-.39-.39-.39-1.02 0-1.41.39-.39 1.02-.39 1.41 0L10 14.17l6.88-6.88c.39-.39 1.02-.39 1.41 0 .39.39.39 1.02 0 1.41l-7.59 7.59c-.38.39-1.02.39-1.41 0z" }, null, -1);
var j = { key: 3, xmlns: "http://www.w3.org/2000/svg", height: "32px", viewBox: "0 0 24 24", width: "32px", fill: "#616161" };
var W = createVNode("path", { d: "M0 0h24v24H0z", fill: "none" }, null, -1);
var q = createVNode("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z" }, null, -1);
var U = { key: 4, xmlns: "http://www.w3.org/2000/svg", height: "32px", viewBox: "0 0 24 24", width: "32px", fill: "#ffffff" };
var X = createVNode("path", { d: "M0 0h24v24H0z", fill: "none" }, null, -1);
var F = createVNode("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z" }, null, -1);
N.render = function(e2, t2, o2, n2, s2, i2) {
  return openBlock(), createBlock("span", B, ["warning" === e2.type ? (openBlock(), createBlock("svg", P, [D])) : "danger" === e2.type ? (openBlock(), createBlock("svg", H, [k])) : "success" === e2.type ? (openBlock(), createBlock("svg", V, [R, $])) : "default" === e2.type ? (openBlock(), createBlock("svg", j, [W, q])) : (openBlock(), createBlock("svg", U, [X, F]))]);
};
var Y = defineComponent({ name: "MToast", components: { MIcon: N }, props: { visible: Boolean, text: { type: String, default: "" }, description: { type: String, default: "" }, toastBackgroundColor: { type: String, default: "" }, type: { type: String, default: "default" }, onClose: { type: Function, default: () => null }, onCloseHandler: { type: Function, required: true }, offset: { type: Number, required: true }, id: { type: Number, required: true }, timeout: { type: Number, default: 5e3 }, position: { type: String, required: true }, showCloseButton: { type: Boolean, default: true }, swipeClose: { type: Boolean, default: true }, hideProgressBar: { type: Boolean, default: false }, showIcon: { type: Boolean, default: false }, transition: { type: String, default: "bounce" } }, setup(e2, t2) {
  const o2 = ref(), { width: n2 } = (() => {
    const e3 = ref(-1), t3 = ref(-1), o3 = (o4) => {
      null !== o4 && null !== o4.currentTarget && (e3.value = o4.currentTarget.innerWidth, t3.value = o4.currentTarget.innerHeight);
    };
    return onMounted(() => {
      window.innerWidth > 0 && (e3.value = window.innerWidth, t3.value = window.innerHeight), window.addEventListener("resize", L(o3));
    }), onUnmounted(() => {
      window.removeEventListener("resize", L(o3));
    }), { width: e3, height: t3 };
  })(), { swipedDiff: s2, startSwipeHandler: i2, swipeStyle: r2, cleanUpMove: l2 } = O(e2.position, e2.onCloseHandler, e2.swipeClose), { transitionType: a2 } = (d = e2.position, v = e2.transition, m = s2, { transitionType: computed(() => m.value > 200 ? "mosha__fadeOutLeft" : m.value < -200 ? "mosha__fadeOutRight" : z[d][v]) });
  var d, v, m;
  const { start: f, stop: _, progress: w } = ((e3, t3) => {
    const o3 = ref(), n3 = ref(0), s3 = ref(t3), i3 = ref(), r3 = ref(100), l3 = () => {
      clearInterval(i3.value), clearTimeout(o3.value);
    };
    return onMounted(() => {
    }), onUnmounted(() => {
      l3();
    }), { start: () => {
      n3.value = Date.now(), clearTimeout(o3.value), i3.value = setInterval(() => {
        r3.value--;
      }, t3 / 100 - 5), o3.value = setTimeout(e3, s3.value);
    }, stop: () => {
      clearInterval(i3.value), clearTimeout(o3.value), s3.value -= Date.now() - n3.value;
    }, clear: l3, progress: r3 };
  })(() => {
    e2.onCloseHandler();
  }, e2.timeout), y = computed(() => t2.slots.default), b = computed(() => /<\/?[a-z][\s\S]*>/i.test(e2.description)), I = () => {
    e2.timeout > 0 && f();
  };
  return watchEffect(() => {
    const { customStyle: t3 } = ((e3, t4, o3) => {
      const n3 = computed(() => {
        switch (e3) {
          case "top-left":
            return { left: "0", top: `${t4}px` };
          case "bottom-left":
            return { left: "0", bottom: `${t4}px` };
          case "bottom-right":
            return { right: "0", bottom: `${t4}px` };
          case "top-center":
            return { top: `${t4}px`, left: "0", right: "0", marginRight: "auto", marginLeft: "auto" };
          case "bottom-center":
            return { bottom: `${t4}px`, left: "0", right: "0", marginRight: "auto", marginLeft: "auto" };
          default:
            return { right: "0", top: `${t4}px` };
        }
      });
      return o3.length > 0 && (n3.value.backgroundColor = o3), { customStyle: n3 };
    })(e2.position, e2.offset, e2.toastBackgroundColor);
    o2.value = t3.value;
  }), onMounted(() => {
    I();
  }), { style: o2, transitionType: a2, startTimer: I, progress: w, onTouchStart: (e3) => {
    i2(e3);
  }, onMouseLeave: () => {
    l2("mousemove"), I();
  }, onMouseDown: (e3) => {
    i2(e3);
  }, swipeStyle: r2, isSlotPassed: y, isDescriptionHtml: b, onMouseEnter: () => {
    e2.timeout > 0 && n2.value > 425 && _();
  } };
} });
var A = { class: "mosha__toast__content-wrapper" };
var G = { class: "mosha__toast__content" };
var J = { class: "mosha__toast__content__text" };
var K = { key: 1, class: "mosha__toast__content__description" };
var Q = { key: 0, class: "mosha__toast__slot-wrapper" };
Y.render = function(e2, t2, o2, n2, s2, i2) {
  const r2 = resolveComponent("MIcon");
  return openBlock(), createBlock(Transition, { name: e2.transitionType, type: "animation" }, { default: withCtx(() => [e2.visible ? (openBlock(), createBlock("div", { key: 0, class: ["mosha__toast", e2.toastBackgroundColor ? null : e2.type], style: [e2.style, e2.swipeStyle], onMouseenter: t2[2] || (t2[2] = (...t3) => e2.onMouseEnter && e2.onMouseEnter(...t3)), onMouseleave: t2[3] || (t2[3] = (...t3) => e2.onMouseLeave && e2.onMouseLeave(...t3)), onTouchstartPassive: t2[4] || (t2[4] = (...t3) => e2.onTouchStart && e2.onTouchStart(...t3)), onMousedown: t2[5] || (t2[5] = (...t3) => e2.onMouseDown && e2.onMouseDown(...t3)) }, [createVNode("div", A, [e2.showIcon ? (openBlock(), createBlock(r2, { key: 0, type: e2.type }, null, 8, ["type"])) : createCommentVNode("", true), createVNode("div", G, [createVNode("div", J, toDisplayString(e2.text), 1), e2.description.length > 0 && e2.isDescriptionHtml ? (openBlock(), createBlock("div", { key: 0, class: "mosha__toast__content__description", innerHTML: e2.description }, null, 8, ["innerHTML"])) : createCommentVNode("", true), e2.description.length > 0 && !e2.isDescriptionHtml ? (openBlock(), createBlock("div", K, toDisplayString(e2.description), 1)) : createCommentVNode("", true)])]), e2.isSlotPassed ? (openBlock(), createBlock("div", Q, [renderSlot(e2.$slots, "default")])) : createCommentVNode("", true), e2.showCloseButton ? (openBlock(), createBlock("div", { key: 1, class: "mosha__toast__close-icon", onClick: t2[1] || (t2[1] = (...t3) => e2.onCloseHandler && e2.onCloseHandler(...t3)) })) : createCommentVNode("", true), e2.hideProgressBar ? createCommentVNode("", true) : (openBlock(), createBlock("div", { key: 2, class: "mosha__toast__progress", style: { width: `${e2.progress}%` } }, null, 4))], 38)) : createCommentVNode("", true)]), _: 3 }, 8, ["name"]);
};
var Z = { "top-left": [], "top-right": [], "bottom-left": [], "bottom-right": [], "top-center": [], "bottom-center": [] };
var ee = 0;
var te = (e2, t2) => {
  const o2 = ee++, n2 = t2 ? se(t2) : C;
  if (e2.__v_isVNode)
    return oe(o2, M.VNODE, n2, e2), { close: () => le(o2, n2.position) };
  if (e2.hasOwnProperty("render"))
    return oe(o2, M.COMPONENT, n2, e2), { close: () => le(o2, n2.position) };
  const s2 = ie(e2);
  return oe(o2, M.TITLE_DESCRIPTION, n2, s2), { close: () => le(o2, n2.position) };
};
var oe = (e2, t2, o2, n2) => {
  setTimeout(() => {
    const s2 = re(o2, Z, 12), i2 = document.createElement("div");
    let r2;
    document.body.appendChild(i2), r2 = t2 === M.VNODE ? createVNode(Y, ne(o2, e2, s2, le), () => [n2]) : t2 === M.TITLE_DESCRIPTION ? createVNode(Y, ne(o2, e2, s2, le, n2)) : createVNode(Y, ne(o2, e2, s2, le), () => [createVNode(n2)]), render(r2, i2), Z[o2.position].push({ toastVNode: r2, container: i2 }), r2.component && (r2.component.props.visible = true);
  }, 1);
};
var ne = (e2, t2, o2, n2, s2) => a(l(l({}, e2), s2), { id: t2, offset: o2, visible: false, onCloseHandler: () => {
  n2(t2, e2.position ? e2.position : "top-right");
} });
var se = (e2) => {
  const t2 = a(l({}, e2), { type: e2.type || C.type, timeout: e2.timeout || C.timeout, showCloseButton: e2.showCloseButton, position: e2.position || C.position, showIcon: e2.showIcon, swipeClose: e2.swipeClose, transition: e2.transition || C.transition });
  return t2.hideProgressBar = void 0 !== t2.timeout && t2.timeout <= 0, void 0 !== e2.hideProgressBar && (t2.hideProgressBar = e2.hideProgressBar), t2;
};
var ie = (e2) => ({ text: "string" == typeof e2 ? e2 : e2.title, description: "string" == typeof e2 ? void 0 : e2.description });
var re = (e2, t2, o2) => {
  let n2 = o2;
  if (!e2.position)
    throw new Error("no position");
  return t2[e2.position].forEach(({ toastVNode: e3 }) => {
    const t3 = e3.el.offsetHeight + o2;
    n2 += t3 || 0;
  }), n2;
};
var le = (e2, t2) => {
  const o2 = Z[t2], n2 = o2.findIndex(({ toastVNode: t3 }) => t3.props && e2 === t3.props.id);
  if (-1 === n2)
    return;
  const { container: s2, toastVNode: i2 } = o2[n2];
  if (!i2.el)
    return;
  const r2 = i2.el.offsetHeight;
  Z[t2].splice(n2, 1), ((e3, t3, o3, n3) => {
    for (let s3 = e3; s3 < t3.length; s3++) {
      const { toastVNode: e4 } = t3[s3];
      if (!e4.el)
        return;
      const i3 = o3.split("-")[0] || "top", r3 = parseInt(e4.el.style[i3], 10) - n3 - 12;
      if (!e4.component)
        return;
      e4.component.props.offset = r3;
    }
  })(n2, o2, t2, r2), i2.component && (i2.component.props.visible = false, i2.component.props.onClose && i2.component.props.onClose(), setTimeout(() => {
    render(null, s2), document.body.removeChild(s2);
  }, 1e3));
};
var ae = () => {
  Object.entries(Z).forEach(([e2, t2]) => {
    if (t2.length > 0) {
      t2.map((e3) => e3.toastVNode.props.id).forEach((t3) => {
        le(t3, e2);
      });
    }
  });
};
var ue = { install: (e2) => {
  e2.config.globalProperties.$moshaToast = te, e2.provide("moshaToast", te);
} };
var mosha_vue_toastify_es_default = ue;
export {
  M as ToastContentType,
  ae as clearToasts,
  te as createToast,
  mosha_vue_toastify_es_default as default,
  S as withProps
};
//# sourceMappingURL=mosha-vue-toastify.js.map
